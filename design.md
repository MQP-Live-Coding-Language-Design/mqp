Language Features
===

# Goals
The goal of this language is to introduce people with no programming experience to the art of live coding music. This is reflected in the easy accessibility of our web-based environment, which requires no initial setup, allowing the user to easily begin live-coding. Additionally, we would like to create an intuitive, minimal language that people can easily grow in.

# Target audience
Ideally this language could allow anyone with internet access to create music without any difficulties. We are hoping to simplify the complexities of programming, to simplify the complexities of music and to combine that into a single interface.

# Features
This language is structured by two different types of sections: **sequences** and **parts**. The distinction between these two is the ability to generate sound. A sequence is composed by a **phrase** and its **modifiers**. A part is composed by an **instrument** and its **filters**.

## Sequences
A sequence is phrase wrapped in `" "` that is formed by groups, followed by a list of modifiers.

### Groups
A group can be formed by one or multiple of the following: **notes**, **numbers** or **percussion**.

A **note** is any letter between `a` and `g` with its octave number, and any note modifier as such: `a5+`. The octave specification and other modifiers are optional, as are all modifiers. Note modifiers are added next to the note and perform **sharp**, **flat**, and **octave** changes.

A **number** can be any integer. The scale can be set with the `scale` sequence modifier. For example, the number `1` in a major scale would be the tonic of that scale, and the number `-2` in a chromatic scale would be the minor seventh of that scale.

A **percussion** symbol is a predetermined character corresponding to a sound.

Groups can behave differently: they can play at the same time as a **chord**, they can play in alternating order as a **step**, they can be **randomized**, and they can be **repeated**.

### Sequence modifiers
Sequence modifiers are added after the phrase is defined. These are modifiers that affect the way the phrase will be played once a **part** is added, and sound is generated from it. Sequence modifiers include **octave**, **pitch**, note **duration** changes, etc.

### Sequence storage
Sequences can be saved for later use. Saving a sequence will store it exactly as it is when the `save` command is reached, and will not save changes made to the sequence after that. When sequences are saved they are given names for reference, which can be used in place of a manually written sequence of notes.

### Sequence combination
Multiple sequences can be combined together in order to create new sequences. These new sequences can be treated like manually created sequences, meaning they can be modified and played as normal. This is useful for example when multiple sequences have been stored and they need to be played in order. The simplest kind of combination is concatenation.

## Parts
A part is a musical interpretation of a sequence. This includes the **instrument** and any part modifiers, that define how the sequence will sound. In the case of notes, an instrument needs to be set for a part to be defined. In the case of percussion, the sounds are predetermined by the phrase, so there is no need to define an instrument. Once the part is defined, **part modifiers** can be added to it.

### Part modifiers
Part modifiers change the way an instrument sounds, by adding sound effects. **Filters** are part modifiers that change the frequencies of the sounds generated by default instruments.

### Part storage
Parts can be saved for reference both in the UI and in the code. Uses for saved parts include:
  - Labeling in the visualization display
  - Stopping and starting individual parts without affecting the sequences they are playing
  - Tracking parts whose code has been deleted (intentionally or not)

# Setups
## Live performance
This language and the environment the language is in will offer features designed to make live coding a streamlined and intuitive process. These features are as follows:
- Iterative modifications and filters allow for on the fly changes to both phrases and instruments
- Naming instruments will allow them to be quickly reused across phrases
- The environment will make it easy to see what instruments and phrases are currently being played
- Piping phrases into instruments allows for instruments to be quickly defined
- Concatenate phrases to define times for each

## Composition
The language also offers some features that allow for song composition. While we have more planned as stretch goals, the following will
allow for some composition:
- Ability to define instruments globally and then use them in phrases
- Ability to save phrases to later edit and put in different instruments

# System and environment
- Built from the bottom up using HTML and JS
- Web based to allow easy access and no setup
- Tone.js was used as to acquire and play the sounds the user typed
- Peg.js was used as our parsing language to pass the user typed code through Tone.js
- Sound visualization to make code readability easier by letting the user see what each instrument is playing
- A small visual window will be used to display each
- Auto-fill allows for the user to quickly write code and remember syntax

# Stretch goals
- We hope to be able to implement a feature that allows for full songs to be created and saved, with a beginning and an end.
- Downloading files of what you've created
- Upload your own MIDIs to use
